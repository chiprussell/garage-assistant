<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Garage Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: white;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .voice-container {
            text-align: center;
            max-width: 400px;
        }

        .voice-circle {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.1);
        }

        .voice-circle:hover {
            transform: scale(1.05);
            box-shadow: 0 25px 80px rgba(102, 126, 234, 0.4);
        }

        .voice-circle.listening {
            animation: pulse 1.5s infinite;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .voice-circle.speaking {
            animation: speak 0.8s infinite;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes speak {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.05); }
            75% { transform: scale(0.95); }
        }

        .status-text {
            font-size: 1.5em;
            margin-bottom: 20px;
            font-weight: 300;
            opacity: 0.9;
        }

        .instruction {
            font-size: 1.1em;
            opacity: 0.7;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .auto-start {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 25px;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }

        .auto-start:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hidden {
            display: none;
        }

        @media (max-width: 480px) {
            .voice-circle {
                width: 150px;
                height: 150px;
                font-size: 3em;
            }
        }
    </style>
</head>
<body>
    <div class="voice-container">
        <div id="voiceCircle" class="voice-circle" onclick="toggleVoice()">🎤</div>
        <div id="statusText" class="status-text">Ready to listen</div>
        <div class="instruction">
            Say: "I have a new bin with tools" or "Where is my screwdriver?"
        </div>
        <button class="auto-start" onclick="enableAutoStart()">Enable Auto-Start</button>
        <button class="auto-start" onclick="showCommands()">Voice Commands</button>
    </div>

    <script>
        let binsData = JSON.parse(localStorage.getItem('garageBins')) || {};
        let isListening = false;
        let isSpeaking = false;
        let recognition = null;
        let autoStartEnabled = localStorage.getItem('autoStart') === 'true';

        // Initialize on page load
        window.onload = function() {
            initializeSpeechRecognition();
            
            // Auto-start if enabled
            if (autoStartEnabled) {
                setTimeout(() => {
                    if (!isListening) {
                        startListening();
                    }
                }, 1000);
            }
            
            // URL parameter support for Siri Shortcuts
            const urlParams = new URLSearchParams(window.location.search);
            const command = urlParams.get('command') || urlParams.get('q');
            if (command) {
                setTimeout(() => {
                    processVoiceCommand(command);
                }, 500);
            }
        };

        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                recognition.onstart = function() {
                    isListening = true;
                    updateUI();
                };

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    if (transcript.trim()) {
                        processVoiceCommand(transcript.trim());
                    }
                };

                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    speakResponse("Sorry, I didn't catch that. Please try again.");
                    isListening = false;
                    updateUI();
                };

                recognition.onend = function() {
                    isListening = false;
                    updateUI();
                    
                    // Auto-restart listening if enabled and not speaking
                    if (autoStartEnabled && !isSpeaking) {
                        setTimeout(() => {
                            if (!isListening && !isSpeaking) {
                                startListening();
                            }
                        }, 2000);
                    }
                };
            } else {
                document.getElementById('statusText').textContent = 'Voice not supported in this browser';
            }
        }

        function toggleVoice() {
            if (!recognition) return;

            if (isListening) {
                recognition.stop();
            } else {
                startListening();
            }
        }

        function startListening() {
            if (recognition && !isListening && !isSpeaking) {
                recognition.start();
            }
        }

        function updateUI() {
            const circle = document.getElementById('voiceCircle');
            const status = document.getElementById('statusText');

            if (isSpeaking) {
                circle.className = 'voice-circle speaking';
                circle.innerHTML = '🔊';
                status.textContent = 'Speaking...';
            } else if (isListening) {
                circle.className = 'voice-circle listening';
                circle.innerHTML = '🎙️';
                status.textContent = 'Listening...';
            } else {
                circle.className = 'voice-circle';
                circle.innerHTML = '🎤';
                status.textContent = autoStartEnabled ? 'Auto-listening enabled' : 'Tap to speak';
            }
        }

        function processVoiceCommand(command) {
            console.log('Processing command:', command);
            const response = processCommand(command.toLowerCase());
            speakResponse(response);
        }

        function processCommand(command) {
            // Add new bin
            if (command.includes('new bin') || command.includes('i have') || command.includes('i put')) {
                return handleNewBin(command);
            }
            
            // Find items
            if (command.includes('where') || command.includes('find')) {
                return handleFindItem(command);
            }
            
            // Show bin contents
            if (command.includes('what\'s in') || command.includes('what is in') || command.includes('show me bin')) {
                return handleShowBin(command);
            }
            
            // List all bins
            if (command.includes('show all') || command.includes('all bins') || command.includes('what bins') || command.includes('list bins')) {
                return handleShowAllBins();
            }
            
            // Clear all data
            if (command.includes('clear all') || command.includes('delete all') || command.includes('reset')) {
                return handleClearAll();
            }
            
            // Help
            if (command.includes('help') || command.includes('what can you do')) {
                return handleHelp();
            }
            
            return "I'm not sure what you want to do. Try saying something like 'I have a new bin with tools' or 'Where is my screwdriver?'";
        }

        function handleNewBin(command) {
            const binMatch = command.match(/bin\s+(\d+)/);
            const binNum = binMatch ? binMatch[1] : getNextBinNumber();
            
            let items = '';
            const withMatch = command.match(/with\s+(.+?)(?:\s+in\s+bin|\s*$)/i);
            
            if (withMatch) {
                items = withMatch[1];
            } else {
                const words = command.split(' ');
                const stopWords = ['i', 'have', 'a', 'new', 'bin', 'and', 'put', 'in', 'with'];
                items = words.filter(word => !stopWords.includes(word.toLowerCase())).join(' ');
            }
            
            if (items) {
                binsData[binNum] = items;
                saveBinsData();
                return `Added bin ${binNum} with ${items}`;
            } else {
                return "I heard you want to add a new bin, but I didn't catch what items to put in it. Try saying 'I have a new bin with screwdrivers and hammers'";
            }
        }

        function handleFindItem(command) {
            const whereMatch = command.match(/where\s+(?:is\s+)?(?:my\s+)?(.+?)(?:\?|$)/i);
            const findMatch = command.match(/find\s+(?:my\s+)?(.+?)(?:\?|$)/i);
            
            const searchTerm = whereMatch ? whereMatch[1] : (findMatch ? findMatch[1] : '');
            
            if (!searchTerm) {
                return "What item are you looking for? Try saying 'Where is my screwdriver?'";
            }
            
            const results = [];
            for (const [binNum, items] of Object.entries(binsData)) {
                if (items.toLowerCase().includes(searchTerm.toLowerCase())) {
                    results.push(binNum);
                }
            }
            
            if (results.length > 0) {
                return `Found ${searchTerm} in bin ${results.join(' and bin ')}`;
            } else {
                return `I couldn't find ${searchTerm} in any of your bins.`;
            }
        }

        function handleShowBin(command) {
            const binMatch = command.match(/bin\s+(\d+)/);
            if (binMatch) {
                const binNum = binMatch[1];
                if (binsData[binNum]) {
                    return `Bin ${binNum} contains ${binsData[binNum]}`;
                } else {
                    return `Bin ${binNum} is empty or doesn't exist yet.`;
                }
            }
            return "Which bin number do you want to see? Try saying 'What's in bin 3?'";
        }

        function handleShowAllBins() {
            if (Object.keys(binsData).length === 0) {
                return "You don't have any bins yet. Say 'I have a new bin with tools' to get started.";
            }
            
            const sortedBins = Object.keys(binsData).sort((a, b) => parseInt(a) - parseInt(b));
            let response = `You have ${sortedBins.length} bins. `;
            
            sortedBins.forEach((binNum, index) => {
                response += `Bin ${binNum} has ${binsData[binNum]}. `;
            });
            
            return response;
        }

        function handleClearAll() {
            binsData = {};
            saveBinsData();
            return "All bins have been cleared.";
        }

        function handleHelp() {
            return `I can help you organize your garage bins. Say 'I have a new bin with screwdrivers and hammers' to add items. Say 'Where is my drill?' to find things. Say 'What's in bin 3?' to check a specific bin. Or say 'Show me all my bins' to hear everything.`;
        }

        function getNextBinNumber() {
            const existingBins = Object.keys(binsData).map(num => parseInt(num));
            return existingBins.length === 0 ? 1 : Math.max(...existingBins) + 1;
        }

        function speakResponse(text) {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                
                const cleanText = text.replace(/[^\w\s,.!?]/g, '').trim();
                const utterance = new SpeechSynthesisUtterance(cleanText);
                
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 0.8;
                
                const voices = speechSynthesis.getVoices();
                const preferredVoice = voices.find(voice => 
                    voice.name.includes('Samantha') || 
                    voice.name.includes('Karen') || 
                    voice.name.includes('Siri') ||
                    (voice.lang.includes('en-US') && voice.name.includes('Female'))
                );
                
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }
                
                utterance.onstart = function() {
                    isSpeaking = true;
                    updateUI();
                };
                
                utterance.onend = function() {
                    isSpeaking = false;
                    updateUI();
                    
                    // Resume listening if auto-start is enabled
                    if (autoStartEnabled) {
                        setTimeout(() => {
                            if (!isListening && !isSpeaking) {
                                startListening();
                            }
                        }, 1000);
                    }
                };
                
                speechSynthesis.speak(utterance);
            }
        }

        function enableAutoStart() {
            autoStartEnabled = !autoStartEnabled;
            localStorage.setItem('autoStart', autoStartEnabled.toString());
            
            if (autoStartEnabled) {
                speakResponse("Auto-start enabled. I'll automatically listen for your commands.");
                setTimeout(() => {
                    if (!isListening) {
                        startListening();
                    }
                }, 2000);
            } else {
                speakResponse("Auto-start disabled. Tap the microphone to talk.");
                if (isListening) {
                    recognition.stop();
                }
            }
            
            updateUI();
        }

        function showCommands() {
            const commands = `Here are some things you can say: I have a new bin with electrical cords. Where is my screwdriver? What's in bin 3? Show me all my bins. Clear all bins. Enable auto start.`;
            speakResponse(commands);
        }

        function saveBinsData() {
            localStorage.setItem('garageBins', JSON.stringify(binsData));
        }
    </script>
</body>
</html>